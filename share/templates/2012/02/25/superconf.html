{% block content %}
<article>
<header>
	<time datetime="2012-02-25" pubdate>2012-02-25</time>
	<h1>{% block title %}Developing Operability{% endblock %}</h1>
</header>

<p><em>I had the pleasure of being invited to speak at <a href="http://superconf.co">SuperConf</a> in Miami about devops.&nbsp; This is what I intended to say and fortunately approximately what I did say.&nbsp; The slides that accompanied are at <a href="http://rcrowley.org/talks/superconf-2012/">http://rcrowley.org/talks/superconf-2012/</a>.</em></p>

<p>Hi, my name is Richard Crowley.&nbsp; I&#8217;m a production engineer at Square.&nbsp; My team&#8217;s responsible for the datacenter environment, network, hardware provisioning, operating system configuration, databases, backups, and monitoring.&nbsp; I work there because I&#8217;m interested in software systems that work well in production.&nbsp; These systems are operable &mdash; it&#8217;s easy for humans to control, change, and grow them as needed.&nbsp; It takes a lot of work to turn your average prototype into an operable system.&nbsp; It&#8217;s not a one-man job and it&#8217;s never the same from company to company so what follows draws heavily from my experience and opinions, which have shown me over and over that developers should own the operability of their systems.&nbsp; It&#8217;s time to get our hands dirty.</p>

<p>I consider myself both a developer and an operator.&nbsp; I help design and implement software systems and care deeply about how they&#8217;re configured, deployed, and debugged in production.&nbsp; After all, the vast majority of an application&#8217;s life is spent being maintained and operated in production.&nbsp; We&#8217;re talking about years, here.&nbsp; It&#8217;s foolish to ignore that future during the relatively shorter design and implementation phases that are typically measured in weeks or months.&nbsp; Alternatively, I may just be OCD, but I think that&#8217;s less likely.&nbsp; Let&#8217;s talk about how I arrived here.</p>

<p>I founded a company called DevStructure with Matt Tanase two years ago.&nbsp; We started with a simple thesis: configuring servers was too hard.&nbsp; With that, we went to work building configuration management tools optimized for software developers.&nbsp; In a way, we were luring developers into caring about operations.&nbsp; We quickly decided that a prerequisite to solving the configuration management problem was reducing the distance between development and production environments.&nbsp; While a Mac laptop is technically a form of UNIX, it&#8217;s a far cry from the Linux servers we all use in production.&nbsp; I see this distance to be a huge problem for the operability of most of our production systems.&nbsp; Matt and I built some tools and embraced others, Vagrant especially, that brought Linux cloud instances and virtual machines into the development workflow.&nbsp; From that base, we launched our Blueprint configuration management tools.&nbsp; Operator- and production-focused configuration management tools like Puppet and Chef were always on our radar and we sought to interoperate with both of them.&nbsp; As is common for bootstrapped startups, I consulted with several companies on developing their configuration management strategy, sometimes using Blueprint, other times using Puppet.</p>

<p>Square just happened to be one of those companies and I&#8217;ve been there full-time since January.&nbsp; Reliability is paramount at Square.&nbsp; It&#8217;s way more important than performance, within reason.&nbsp; If a merchant can&#8217;t accept a payment, we&#8217;ve failed.&nbsp; Historically, environments that value reliability fear change.&nbsp; We&#8217;re different.&nbsp; We move fast &mdash; there are many engineering teams working on many products &mdash; but despite that it&#8217;s critical we don&#8217;t break things.&nbsp; Matthew O&#8217;Connor, our director of engineering, says it&#8217;s rude to break the site.&nbsp; I couldn&#8217;t agree more.&nbsp; Let&#8217;s not be rude to our customers.</p>

<p>There&#8217;s a buzzword out there &mdash; devops &mdash; that I don&#8217;t care for too much.&nbsp; It&#8217;s helpful though, because finding a name that stuck has accelerated the idea that reducing the distance between development and production makes it possible to build more reliable systems.&nbsp; The key, though, is that it&#8217;s really about reducing the distance between developers and operators.&nbsp; It&#8217;s about people &mdash; developers and operators.&nbsp; As the agile mafia said, we value &#8220;individuals and interactions over processes and tools.&#8220;</p>

<p>Perhaps it&#8217;s because developers have already blazed the agile trail but to me, the devops movement has always felt lopsided &mdash; it&#8217;s very operator-focused.&nbsp; Case-in-point: its most visible sea change is the degree to which systems administrators are taking to high-level programming languages, learning to design software instead of &#8220;writing scripts,&#8221; and embracing agile development methods.&nbsp; We&#8217;re focusing on people, on working software, on customers, and on our response to change.</p>

<p>The goal, after all, is to create business value.&nbsp; I&#8217;m as guilty as anyone here in getting too absorbed in compiler flags, sysctls, or coding style and losing sight of the reality that I work for a company.&nbsp; I have to remind myself that customers never have and never will care about load average.&nbsp; We all need to focus on creating business value, and as developers and operators...</p>

<p>...we should measure that value.&nbsp; Someone, I think either John Vincent or Theo Schlossnagle, likes to say, &#8220;If you don&#8217;t monitor it, it doesn&#8217;t exist.&#8221;&nbsp; And if it doesn&#8217;t exist, well, what are you working on?&nbsp; A recent conversation with one of the dozen or so Eri[ck]s at Square gave us a good interview question: if you could monitor only one thing, what would it be?&nbsp; We decided we would monitor whether the site is on the Internet.&nbsp; An oversimplification, to be sure, and one that doesn&#8217;t help much with debugging, but it&#8217;s a start.&nbsp; Undoubtedly, you&#8217;ll expand from there and when you do, try to create metrics that answer questions.&nbsp; Remember that, by and large, these metrics are for human consumption.&nbsp; Responding to changes in metrics should be part of every company&#8217;s culture.</p>

<p>You see, devops is a cultural thing.&nbsp; Reducing the distance between developers and operators requires moving past the historic us-versus-them attitude.&nbsp; Traditional systems administration consumes less time these days, thanks to innovations in managed hosting, virtualization, and provisioning APIs like EC2.&nbsp; But operators aren&#8217;t taking more vacation, we&#8217;re contributing to the software development process.&nbsp; On the flip side, we as developers are hopefully doing more than checking in code and going home.&nbsp; Helping each other out leads to trust.&nbsp; Operators have to trust that developers aren&#8217;t rolling out new features to ruin the operator&#8217;s sleep.&nbsp; Developers also have to trust that operators don&#8217;t say &#8220;no&#8221; because they hate you.</p>

<p>DevOps is certainly first and foremost a cultural solution to a cultural problem between two teams with different incentives.&nbsp; But we are all engineers, we&#8217;re makers of tools, and basically we can&#8217;t help ourselves.&nbsp; Thus, the tools we write codify the culture we create.&nbsp; Configuration management, deployment, and monitoring tools are the most visibly affected software genres but it extends further to collaboration and project management, documentation, and even our office jukebox.&nbsp; Much like writing clarifies the author&#8217;s beliefs, working software makes fuzzy human interactions concrete and unambiguous.</p>

<p>If there&#8217;s a common theme to all these tools, it&#8217;s automation.&nbsp; We automate to reduce the number of errors and inconsistencies present in our infrastructures.&nbsp; We automate to make ourselves more efficient.&nbsp; We can&#8217;t leverage the raw power of thousands of computers if it takes us six months to configure them all.&nbsp; My rule of thumb here is that you should never perform a manual process a third time.&nbsp; This works at many layers of abstraction: it&#8217;s OK to manually install an operating system once to get your feet wet but the second time, you should be using PXEBoot and Kickstart or preseed files to automate the installation.&nbsp; Higher up the stack in the realm of developers, it&#8217;s fine to manually craft a software build process that&#8217;s just right but subsequent builds should be performed automatically, perhaps through a continuous integration tool like Jenkins or Buildbot.</p>

<p>Through all this automation, every layer of our infrastructure is being defined by code instead of wiki pages full of prose and syntax errors.&nbsp; But it&#8217;s more than just working code.&nbsp; There&#8217;s a subtle distinction here I want to make explicit: we&#8217;re not talking about &#8220;scripts&#8221; anymore; we&#8217;re not talking about <code>cat</code>ing Bash history into <code>doit.sh</code>; we&#8217;re talking about well designed software systems that provide abstractions that make developers and operators more powerful.</p>

<p>The arrival of these distinctly computer science concepts in operations &mdash; abstraction, encapsulation, and polymorphism to name but a few &mdash; doesn&#8217;t align with what I see as a distinct lack of traditional software developers getting serious about operations.&nbsp; Systems administration is no longer a cowboy culture of Perl and shell. One-liners grown out-of-control are being tamed.&nbsp; Operations are being driven by well-designed software systems built by systems administrators looking for a better way.&nbsp; So I have to ask: where are my fellow developers?</p>

<p>This actually brings us back to DevStructure and the Blueprint project.&nbsp; Matt and I ask developers to work in realistic development environments &mdash; a real operating system, real web servers, and real database servers.&nbsp; No toys.&nbsp; No substitutes.&nbsp; In return Blueprint can, in one command, enumerate all the packages installed by all the package managers, tar up software installed from source code, collect system configuration files that have changed, and learn which services are running.&nbsp; In short, Blueprint makes ad-hoc configuration repeatable.&nbsp; But there&#8217;s another benefit to developers working in realistic development environments: when we do, we start to think just a little more like operators and the distance between the two camps shrinks.</p>

<p>As the distance shrinks, we start to think about the code we write in terms of the service it provides.&nbsp; And that service has to survive the harsh realities of production &mdash; rapidly growing traffic, out-of-memory errors, limited disk and network I/O bandwidth, and all the possible failures other services in the infrastructure may experience.</p>

<p>This is service-oriented architecture.&nbsp; All sufficiently large engineering organizations go through the transformation from a monolithic application to SOA at some point.&nbsp; Don&#8217;t be intimidated, though, because if you squint just right, everyone starts with SOA, too: your application is a service which relies on your database service.&nbsp; I&#8217;m not suggesting that everyone in the audience with a monolithic Rails app should immediately start breaking it apart.&nbsp; Premature refactoring is a sure way to factor out the wrong functionality and drive yourself crazy.&nbsp; Instead, design software that&#8217;s easy to refactor.</p>

<p>One strategy which I think accomplishes this is to begin with a library-oriented approach within your monolithic application.&nbsp; Package logical components of your application independently &mdash; literally as separate gems, eggs, RPMs, or whatever &mdash; and maintain them as internal open-source projects.&nbsp; This strategy works fantastically for GitHub and I can report it has made a difference at Square, too.&nbsp; This approach combats the tightly-coupled spaghetti so often lurking in big codebases by giving everything a Right Place in which to exist.&nbsp; It encourages reuse within your application and leaves the door open for reuse across services in the future.&nbsp; But perhaps the biggest benefit, and one which I didn&#8217;t fully appreciate until very recently, is the ease with which a coworker can familiarize themselves with small libraries and begin to contribute.</p>

<p>Let&#8217;s talk about deployment.&nbsp; Whether you&#8217;re deploying a monolithic application, a set of libraries, or a set of services, the act of deploying new software can be frightening.&nbsp; It doesn&#8217;t have to be.&nbsp; Conventional wisdom says operators fear change so we block deploys for as long we can.&nbsp; Eventually, though, the buildup of new features and improvements is so compelling that the suits demand a deploy.&nbsp; Calamity frequently ensues because the team frankly isn&#8217;t very good at doing deploys.&nbsp; And how do we get better at something?&nbsp; Practice.&nbsp; Automate your deploy process.&nbsp; Make deploys cheap so you can have lots of small deploys.&nbsp; Now operators don&#8217;t fear the armageddon following every deploy and developers aren&#8217;t frustrated that their feature is languishing in staging.</p>

<p>Remember, this is still about creating business value and even though the lines have blurred, operators still increase value by providing a high-performance, highly-available service to customers and developers still increase value by releasing new features.&nbsp;  Of course...</p>

<p>...not one of those features creates any business value until it&#8217;s deployed.&nbsp; As always when we suspect we&#8217;re creating business value, it&#8217;s our job, and usually our first instinct as engineers, to measure this value.</p>

<p>We know the most important metric is whether your site is on the Internet.&nbsp; Beyond that, monitor what makes your business tick: signups, uploads, downloads, 400s, 500s, transactions, cancellations, cash money, and so on.&nbsp; Note well that I haven&#8217;t mentioned CPU, load average, or any other system metric.&nbsp; System metrics are invaluable given the appropriate context but without that context, you can&#8217;t say that 70% CPU or a load of 47 is actually a bad thing.&nbsp; If, however, these correlate strongly with problems experienced by users, you&#8217;ve got a promising avenue to take in debugging.&nbsp; Developers should all be intimately familiar with all of these metrics and use them as their eyes in production when diagnosing problems.</p>

<p>Let&#8217;s talk again about developers getting involved with operations.&nbsp; What follows is a short and highly unscientific selection of operational concerns most developers hand-wave away.&nbsp; I think developers should have answers to these questions before services reach production.</p>

<p>How is this deployed?&nbsp; There are really two questions here: the cultural and the mechanical.&nbsp; The cultural part is about defining the process you use to deploy software.&nbsp; How often?&nbsp; Who initiates the deploy?&nbsp; How can you tell it was successful?&nbsp; The mechanical part should be a reflection of that culture.&nbsp; If you have test-driven-development tattooed on your chest then you may think deploying every green CI build automatically is the way to go.&nbsp; Many teams decouple testing from deployment and prefer to use SSH-based tools like Capistrano and Fabric directly to drive their deploys.&nbsp; Some companies want their deploy history to be auditable, only sometimes due to government or industry regulations, and they tend to tag deploys in version control and deploy with RPMs or Debian packages.</p>

<p>How is this rolled back?&nbsp; All software has bugs.&nbsp; All test suites miss bugs.&nbsp; These are facts of life.&nbsp; John Allspaw suggests, then, that we minimize our mean time to respond to these failures even at the expense of our mean time between failures.&nbsp; As always, there are several common strategies.&nbsp; Many companies prefer to have a fast-path to redeploy the previously-deployed version of the application, thus recovering from an incident.&nbsp; Tools like Capistrano all but assume this is what you&#8217;re doing and deploy into timestamped directories with a symbolic link to the current release so rollbacks are easy.&nbsp; Other companies prefer only rolling forward, meaning a new deploy must be made to address the failure.&nbsp; Sometimes this is as easy as reverting the offending commit and deploying again.&nbsp; Other times, especially when database migrations are involved, rolling forward is the only way.&nbsp; Having the ability to disable features entirely without doing a full deploy, a technique known as feature flagging, takes a bit of the time pressure off of the developers charged with finding a permanent solution in a roll-forward situation.</p>

<p>How is this process (re)started?&nbsp; A special concern both when deploying and rolling back is how quickly old code can be swapped out for new code.&nbsp; You can&#8217;t deploy frequently if each deploy brings along a 30-second outage.&nbsp; In such cases or when the deploy process takes a long time, rolling deploys of one or a few servers at a time amortize the cost and hide it from users.&nbsp; Deploys may be expensive in terms of database connections or briefly elevated network traffic so deploying one server at a time can lessen the impact.&nbsp; Regardless of whether you perform all-at-once or rolling deploys, take care to gracefully finish requests that are in-flight so you don&#8217;t aren&#8217;t guaranteed to serve a few 500s on every deploy.</p>

<p>How is this process supervised?&nbsp; There are two high-level options here: direct parent supervision and periodic supervision.&nbsp; Direct parent supervision comes via tools like daemontools, Runit, and Upstart.&nbsp; They operate by forking and execing your process as a child.&nbsp; Then the parent blocks waiting on the child to exit, at which point the cycle begins again with the parent forking.&nbsp; The Achilles&#8217; Heel of direct parent supervision is that it can&#8217;t be used to supervise processes like Nginx or Unicorn that perform a certain style of zero-downtime restart.&nbsp; These processes restart by forking, which, thanks to good ol&#8217; UNIX semantics, inherits the listening file descriptor, and executing a new copy of themselves which resumes accepting connections on the inherited file descriptor.&nbsp; Once operational, the child signals the parent and the parent exits.&nbsp; The child is then reparented to init and the direct parent supervision relationship is broken.&nbsp; The periodic variety, like Monit, checks the system&#8217;s process table or listening sockets every few seconds, starts the process anew if necessary, and goes back to sleep.&nbsp; These tools can incur significantly more downtime in case of failure by sleeping several seconds before recognizing a process has exited unexpectedly.</p>

<p>What if two versions are live at once?&nbsp; This may seem like a fringe concern but unless you take a complete outage for every deploy, you have this problem.&nbsp; Solving it means ensuring new versions of the code can speak to old versions and vice versa.&nbsp; The greater your tolerance here, the more you can do with A/B testing, canary deploys, and beta launches.&nbsp; Database schema migrations present by far the most common challenge to running two versions at once.&nbsp; It takes only three steps to get it right.&nbsp; First, you must deploy a version of your application which tolerates both the new and the old schema.&nbsp; Then you&#8217;re free to do the database migration and any data backfills that are necessary.&nbsp; Finally, you&#8217;re free to remove special cases for the old schema.</p>

<p>What metrics are important?&nbsp; I don&#8217;t know your answer to this question because I don&#8217;t know what your business values.&nbsp; You know, though, and once you&#8217;ve settled on the &#8220;what,&#8221; it&#8217;s time to determine the &#8220;how.&#8221;&nbsp; I can&#8217;t recommend Graphite highly enough as the final destination for all your time-series metrics but it leaves the collection as an exercise to the reader.&nbsp; Metrics that naturally map to regular intervals can be sent to Graphite via a plaintext protocol.&nbsp; Metrics that don&#8217;t emit on a regular interval, such as page views and their HTTP status codes, database or other service query times, and so on may be aggregated into Graphite&#8217;s time series by Etsy&#8217;s StatsD.&nbsp; And system metrics like CPU, load average, memory use, and I/O are easily gathered by collectd and its bajillion plugins, and forwarded to Graphite.&nbsp; Outside of the mechanics of gathering system metrics, reflect on and document how you expect them to change as your business grows because they&#8217;ll be key to your capacity planning.</p>

<p>The theme that runs through all of these operational concerns and the myriad I didn&#8217;t address is that the best solutions tend to involve collaboration between development and operations which tends to result in a specific contract made between application and platform.&nbsp; Standards like CGI, Rack, and WSGI paved the way but don&#8217;t extend far enough.&nbsp; Heroku provides a standard operating environment for all sorts of applications built from environment variables, file descriptors, and a healthy dose of documentation that informs an application of the addresses and credentials of related services.&nbsp; At Square we&#8217;re standardizing how we deploy services through a library called Jetpack, which is available on GitHub, that deploys and supervises JRuby-based services in a consistent manner.</p>

<p>We&#8217;ve covered a lot of ground here but these tools and these questions should be very familiar territory to the systems administrators you work with.&nbsp; Talk to them.&nbsp; Simply getting to know the other guys is often enough to set developer and operator culture on a path towards mutual trust that&#8217;s critical to a business&#8217; success.&nbsp; No one is better suited than the developers to answer the questions we&#8217;ve asked, to build deploy tools, and to collect metrics on all parts of your business.&nbsp; The operability of your systems depend on it.</p>

<p>If you want to help build infrastructure to revolutionize payments, talk to me or head to <a href="http://squareup.com/jobs">squareup.com/jobs</a>.</p>

<p>That&#8217;s all.&nbsp; Thank you.</p>

</article>
{% endblock %}
