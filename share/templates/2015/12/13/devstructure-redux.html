{% block content %}
<article>
<h1>{% block title %}DevStructure Redux{% endblock %}</h1>

<p>Five years ago Matt Tanase and I built a tool called <a href="http://devstructure.com/blueprint/">Blueprint</a> under the banner of a company we called DevStructure.&nbsp; We believed configuring development environments was too difficult and that existing configuration management tools were too hard to use.&nbsp; This, we concluded, resulted in development environments that were too far removed from their production environments and thus offered little proof that software will work well once deployed to production.</p>

<p>We started with a paid semi-hosted development environment and eventually backed off to a set of open-source tools we hoped to support with production hosting offerings.&nbsp; To cut a long story short, we never made it that far.&nbsp; As a business, DevStructure was a failure.</p>

<p>Early this morning while standing in the dark gently bouncing my two-month-old daughter back to sleep I was thinking about what we built and why we failed.&nbsp; If I was ever bitter about our failure as a business I&#8217;m long since over it but now I see the world through DevStructure-colored glasses; I see shades of what we tried to do in all sorts of tools being released all across our industry.&nbsp; Perhaps that&#8217;s confirmation bias but it keeps me thinking about how I&#8217;d approach the problem today.&nbsp; And let&#8217;s be very clear:&nbsp; The management of development environments that are reliable predictors of how software will behave in production environments is still a major threat to software quality five years later.</p>

<p>However, since I adore <a href="https://slack.com/jobs">my job</a> and since chasing this idea would be a costly distraction for us right now, DevStructure Redux isn&#8217;t going to be coming from me anytime soon.&nbsp; Consider this a free idea or idle ramblings, whichever you choose.</p>

<p>Blueprint was trying to put a better user interface on configuration management and even the idea of infrastructure as code but the tools we built were quite hostile towards code review.&nbsp; Nowadays, I believe code review is essential so I&#8217;ve resumed seeking code-centric user interface improvements.</p>

<p>Today&#8217;s configuration management suffers as a user interface in part because it is built on command-line tools readily available on the servers being managed.&nbsp; Most operators can resist the temptation to <code>apt-get install ...</code> in production but basically no one can resist in a development environment.&nbsp; And why would they?&nbsp; The edit-save-run cycle is a drag and over time most Chef or Puppet runs tend towards oh-my-god-this-is-slow.</p>

<p>So this is where my mind was at 5 o&#8217;clock this morning.&nbsp; I thought that if configuration management was a concern of the operating system then the interface it ultimately exposed could be made more amenable to code review.&nbsp; Here we go with the hand-waving.</p>

<p>Code review-conducive package installation is the easiest to tackle.&nbsp; Whatever the interface, there just needs to be a file or directory tree naming the packages to be installed and specifying their versions.&nbsp; When changes are made the operating system needs to add and remove packages to suit.  Changes may be allowed via editor, command-line tool, or pulling changes from an upstream source code repository.&nbsp; Hypothetically this could be as simple as files like <code>/etc/packages/<em>mysql-server</em></code> that contain the desired version number.&nbsp; Version control <code>/etc</code> and send all the changes through code review.</p>

<p>Immediately after installing a package folks tend to configure the newly-installed software.&nbsp; Detecting meaningful changes to these files was always a major problem for Blueprint.&nbsp; Well-behaved packages mark their configuration files and include hashes of the packaged content to enable detection of changes.&nbsp; In my opinion we&#8217;d be better-served by packages devoid of configuration files.&nbsp; Programs would thus be required to function sanely by default or fail immediately at the author&#8217;s discretion.&nbsp; Imagine how wonderful it would be if this requirement were imposed on all packages:&nbsp; <code>/etc</code> would be empty on a fresh operating system installation!&nbsp; If the defaults don't suit you, create <code>/etc/<em>my.cnf</em></code> containing your desired configuration and commit it, too.</p>

<p>While we&#8217;re moving configuration files out of packages, let&#8217;s get rid of maintainer scripts, too.&nbsp; I want to control when services are started and restarted.&nbsp; I want to control user and group IDs.&nbsp; And I reserve the right to manage these actions and resources differently in my infrastructure than you do in yours.&nbsp; Store service dependencies in <code>systemd</code> units like <code>/etc/systemd/system/<em>mysql.unit</em></code>.&nbsp; Store users and groups in <code>/etc/passwd</code> and <code>/etc/group</code> but without all the cruft or better yet in <code>/etc/passwd.d</code> and <code>/etc/group.d</code> directories.&nbsp; And version them just like packages and configuration files.</p>

<p>Oddly, despite my desire to move maintainer scripts from packages out into configuration management, I also want to get rid of <code>exec</code> or <code>execute</code> resources that allow today&#8217;s configuration management tools to run arbitrary commands.&nbsp; Puppet&#8217;s documentation has long said that if you find yourself using a lot of <code>exec</code> resources you&#8217;re wrong and should be writing your own types and providers.&nbsp; Everyone ignored that because <code>exec</code> resources are easy.&nbsp; The real problem underlying all of this, though, is that it is easier to manage many aspects of a server today via commands than via files (<code>iptables</code>(8), <code>mount</code>(8), <code>sysctl</code>(8), to name but a few) and tough to manage small changes to large sets of defaults (basically every default configuration file).&nbsp; This needs to change if we're to make anything but superficial lipstick-on-a-pig progress.&nbsp; It's no accident this is starting to sound a little bit like Plan 9.</p>

<p>If we were starting DevStructure again today our company would look a whole lot more like CoreOS than like Chef or Puppet Labs.&nbsp; My vision for a minimal operating system, however, is quite different than that of CoreOS.&nbsp; I envision a base installation chock full of all the tools I could ever need to introspect the system.&nbsp; I envision a package manager that enables and encourages fat packages, explicit dependency versioning and vendoring, and then gets out of the business of configuration and orchestration.&nbsp; I envision configuration management being the only interface for adding and removing software or changing its configuration.&nbsp; I envision that all aspects of the operating system will be designed to be version-controlled.&nbsp; I envision packaging to be the obvious best way to deploy your own software into production.</p>

<p>DevStructure Redux would sell an appliance or service (customer&#8217;s choice) that turn this minimal operating system distribution into a streamlined development-to-production pipeline.&nbsp; At a minimum, it would need to accept and serve package artifacts, integrate with test runners and code review tools, store package artifacts installed from the Internet so precise versions are available to all servers, manage server inventory, and orchestrate reconfiguration and deployments.&nbsp; The toughest product challenge is, I think, how to infiltrate brownfield environments.&nbsp; Failure is imminent if this product gives anyone the impression it&#8217;s an all-or-nothing proposition; customers need to derive value immediately and in proportion to their investment.</p>

<p>Alas, I will not have the opportunity to take up this cause again for a long time because I love my job.&nbsp; Our development environments at Slack are not terribly portable to other applications or workflows but they are amazingly production-like and highly optimized for our 100+ engineers getting work done.&nbsp; Seeing this scale does nothing but reinforce my belief that development environments should be as close of a match to production as possible.&nbsp; I&#8217;m not satisfied with the latest batch of abstractions over the ever more complex software systems being built today but I&#8217;ll keep searching.&nbsp; I sincerely hope someone builds what I&#8217;ve described above because I&#8217;d love to buy it.</p>

</article>
{% endblock %}
